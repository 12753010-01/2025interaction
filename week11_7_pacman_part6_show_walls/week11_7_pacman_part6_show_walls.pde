//week11_7_pacman_part6_show_walls
//修改自week11_6_pacman_part5_wall_turning_point
//小精靈 張嘴(在動)而且嘴巴的方向dir會轉動

void setup(){
  size(600,600); // 改一下視窗的大小,讓它是30的倍數
}

int x = 300-15, y = 300-15, dx=0, dy=0, dir = 0; // direction
int next = -1;
float m=0 , dm=0.05 ; // 嘴巴大小mouth , 嘴巴改變量diff of m
boolean[][] bean_eaten = new boolean[20][20]; // Java的二維陣
int [][] walls = {
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},//20個0,代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},//20個0,代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},//20個0,代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},//20個0,代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},//20個0,代表沒有牆
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},//中間都是牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},//20個0,代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},//20個0,代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},//20個0,代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},//20個0,代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},//中間都是牆
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},//20個0,代表沒有牆
};

void draw(){
  background(0);
  boolean canMoveX=true,canMoveY=true;
  for(int i = 0; i < 20; i++){ // 左手i 對應y座標
    for(int j = 0; j < 20; j++) { // 左手j 對應x座標
      if(walls[i][j]==1){
        fill(255);//白色方塊牆
        rect( j * 30, i * 30, 30, 30);
      if(j*30 <= x+dx*15 && x+dx*15 <= j*30+30 && i*30 <=y  && y  <= i*30+30) canMoveX = false;
      if(j*30 <= x  && x  <=j*30+30 && i*30 <= y+dy*15 && y+dy*15 <= i*30+30 ) canMoveY = false;
      
    }else if (bean_eaten[i][j]==false){
        fill(255); // 白色的豆子
        ellipse(15 + j * 30, 15 + i * 30, 5, 5); 
        if (dist(x, y, 15 + j * 30, 15 + i * 30) < 15) {
          bean_eaten[i][j] = true;
        }
      }
    }
  }
  fill(255,255,0); // 黃色的
  float m0 = dir * PI / 2; // 幾個"半PI"有幾個90度
  arc(x, y, 30, 30, m0 + m , m0 + PI * 2 - m); 
  

  if (x + dx >= 05 && x + dx <= 600 - 15 && canMoveX) x += dx;  // 不超過邊界
  if (y + dy >= 05 && y + dy <= 600 - 15 && canMoveY) y += dy;  // 不超過邊界

  // 轉換方向，檢查是否能移動
  if ((x - 15) % 30 == 0 && (y - 15) % 30 == 0 && next != -1) {
    // 根據 `next` 設定方向
    if(next == 2) { dx = -1; dy = 0; dir = 2; } // 左
    if(next == 0) { dx = 1; dy = 0; dir = 0; }  // 右
    if(next == 3) { dx = 0; dy = -1; dir = 3; } // 上
    if(next == 1) { dx = 0; dy = 1; dir = 1; }  // 下
    next = -1;  // 清空下一個方向
  }
  
  // 嘴巴的大小反向變化
  if (m >= 1 || m < 0) {
    dm = -dm; // 正負倒過來
  }
  m += dm;
}

void keyPressed(){
  // 根據按鍵設置 `next` 方向
  if(keyCode == LEFT) next = 2;
  if(keyCode == RIGHT) next = 0; 
  if(keyCode == UP) next = 3;
  if(keyCode == DOWN) next = 1;
}
